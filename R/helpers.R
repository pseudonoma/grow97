#' Automatically process an OD dataset
#'
#' A helper function used by [`extract_blanks()`] and [`quick_analyze()`].
#' Using the supplied path for a folder containing a project's data files,
#' the function detects the prefix format for the data files and calls [grow96::processODData()]
#' with the appropriate arguments.
#'
#' @param projectPath The path of the project folder containing the spec and raw files
#' to be processed.
#'
#' @return A tidy tibble of all data from all experiments and replicates in the project.

auto_process <- function(projectPath){

  message("\nProcessing OD Data...")

  if(any(startsWith(dir(projectPath), "raw_"))){ # if any files in projectPath starts with "raw_"
    message("Detected \"raw_\" prefix for data files")
    data <- grow96::processODData(specPath = projectPath,
                                  dataPath = projectPath)
  } else { # assuming that if no files start with "raw_" then this is the only other possibility.
    message("Detected no prefix for data files")
    data <- grow96::processODData(specPath = projectPath,
                                  dataPath = projectPath,
                                  filePrefix = "") # explicitly no prefix for data files
  }


  return(data)

} # end auto_process().


#' Automatically generate a quality control report for an OD dataset.
#'
#' A helper function used by [`quick_analyze()`].
#'
#' This function generates a quality control analysis for a project, saving it as a PDF
#' in the project's folder.
#'
#' @details
#' `auto_QC()` calls [grow96::qcODData()] and outputs a PDF of the report automatically.
#' Importantly, it also detects if a project has valid blanks based on the presence of data
#' in `$qcBlanks`, which is then passed to the helper function [`auto_blank()`].
#'
#' # Notes
#' This function currently can't tell if valid blanks are missing from only some replicates
#' of an experiment. This is because `$qcBlanks` will only be NULL if an entire experiment
#' fails to have blanks calculated for it.
#'
#' @param data The tibble to analyze, as generated by [`grow96::processODData()`].
#' @param projectPath The path of the project folder containing the spec and raw files
#' to be processed.
#'
#' @return A logical value indicating if blanks were detected (`"TRUE"`) or not (`"FALSE"`)

auto_QC <- function(data, projectPath){

  hasBlanks <- !is.null(grow96::qcODData(data,
                                         path = projectPath,
                                         silent = FALSE)[["qcBlanks"]]
  )
  # NTS: qcBlanks will is.null = TRUE only if data *doesn't* have blanks.

  return(hasBlanks)

} # end auto_QC().


#' Automatically blank OD data.
#'
#' A helper function used by [`quick_analyze()`].
#' This function calls `grow96::blankODs()` to calculate blanked ODs using either blanking data
#' from a project's own dataset, or supplied externally through the argument `blankData`.
#'
#' When calling `grow96::blankODs()`, this function supplies the argument `method = "fixed"`
#' in order to calculate blanks using externally supplied values. See [`grow96::blankODs()`] for
#' more information on how blanking is implemented.
#'
#' @param data The tibble to analyze, as generated by [`grow96::processODData()`].
#' @param forceBlanking Logical value; if `TRUE`, blanking will use externally supplied blanks
#' regardless of whether the project has its own blank data.
#' @param hasBlanks Logical value from `auto_QC()`, indicating if the project has blank data.
#' @param blankData OD values for blanking. Can be a single value or a data frame of values.
#'
#' @return The original tibble, with an added column `blankedOD`.

auto_blank <- function(data, forceBlanking, hasBlanks, blankData){

  message("\nBlanking data...")

  # Catch missing blanks
  if(forceBlanking & is.null(blankData)){
    stop("forceBlanking is TRUE but no blanks have been provided!")
  }

  if(forceBlanking == TRUE){
    message("Ignoring any internal blanks; calculating using supplied values.")
    data <- grow96::blankODs(data,
                             method = "fixed",
                             values = blankData)
  } else if(hasBlanks == TRUE){
    message("There are blanks in this dataset; using them for blanking.")
    data <- grow96::blankODs(data)
  } else if(hasBlanks == FALSE){
    message("This dataset has no blank data; using supplied values instead.")
    data <- grow96::blankODs(data,
                             method = "fixed",
                             values = blankData)
  }

  return(data)

} # end auto_blank().


#' Automatically correct variant column names.
#'
#' A helper function used by [`quick_analyze()`] and [`extract_blanks()`].
#' This function (a) checks the column names of a dataframe against a character vector, renaming
#' them accordingly, and (b) checks cases in one column against a key, reassigning them accordingly.
#'
#' `auto_rename()` should only be used for minor variations in variable naming between projects,
#' such as `Drug` also being named `drug`, `drugs`, or `Drugs`. The function uses a "core" word
#' for string matching, since it seems quite unsafe to automatically correct variable names that
#' differ too much. If your variable is somehow named e.g. `drg`, you're on your own.
#'
#' Reassigning values can only be done on one column at this time.
#'
#' @importFrom dplyr rename select
#' @importFrom stringr str_which regex
#'
#' @param data The dataframe or tibble with column names to check.
#' @param testNames A character vector of correct column names to check for, and use to rename
#' incorrect column names if necessary.
#' @param testKey A dataframe to use as a key for replacing values in a column, as defined by the
#' first column of the key.
#'
#' @return The original dataframe or tibble, with corrected column names if applicable.

auto_rename <- function(data, testNames, testKey){

  ### Fix 1: column names ###
  if(!is.null(testNames)){
    message("Checking column names against supplied ones...")

    # Test: are ALL the name tests present?
    if(all(is.element(testNames, names(data)))){
      # if is.element() returns all TRUE, then all() is TRUE and all (names) are correct
      message("Column names checked and appear correct.")
    } else {
      # begin rename procedure
      message("At least one column name appears incorrect; renaming.")

      # get indices of variants in names(data)
      where <- c()
      for(test in 1:length(testNames)){
        where <- append(where,
                        stringr::str_which(names(data),
                                           stringr::regex(testNames[test], ignore_case = TRUE))
        )
      }

      # Compile list of actual (existing) variant names
      oldNames <- c(names(data)[where])

      # Create renaming key
      key <- setNames(oldNames, testNames)

      # Rename
      data <- dplyr::rename(data, any_of(key))
    }


    ### Fix 2: values in a column ###
  } else if(!is.null(testKey)){

    # define the column to change
    targetCol <- names(key[1])
    message(paste0("Checking values in column ", targetCol, ": \n"))

    # extract a sub-key containing only reference and relevant variant column
    subKey <- testKey |>
      dplyr::select(all_of(targetCol), # reference is determined by first col of key
                    folders[project])|>  # variant is relative to project
      # dplyr::filter(!is.na(folders[project])) # doesn't seem to work on colnames?
      # dplyr::filter(complete.cases(.)) # this doesn't work either, people be lyin on the internet
      na.omit()

    # construct testcase:
    # testData <- dataPackage[[project]][["processed_data"]]

    # construct vector for replacement
    replacements <- subKey[ ,targetCol][match(data[[targetCol]], subKey[ ,2])] # new values
    originals <- testData[,targetCol][!is.na(replacements)] # old values

    if(all(is.na(replacements))){
      # replacements are all NA, so all() returns TRUE
      message("No valid replacements in this column.")
    } else {
      # replace elements of testData$`targetCol` that match non-NA replacements
      data[[targetCol]][!is.na(replacements)] <- replacements[!is.na(replacements)]

      # report changes because of paranoia (maybe this should be a warning?)
      message(paste(unique(originals[!is.na(originals)]),
                    "replaced with", unique(replacements[!is.na(replacements)]), "\n"))
    }
  }


  return(data)

} # end auto_rename().
